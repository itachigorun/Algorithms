# itachigorun   2017-08-12


01背包问题

题目:
有N种物品和一个容量为V的背包，每种物品都有无限件可用。放入第i种物品的费用是Ci，价值是Wi。
求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。

基本思路:
F[i,v]代表前ii件物品放入容量为vv的背包可以获得的最大价值。 01背包的状态转移方程为:
F[i,v]=max{F[i−1][v],F[i−1][v−Ci]+Wi}
将“前i件物品放入容量为v的背包”中这个子问题，只考虑第i件物品的策略(放或不放）。如果放入i物品，问题转为“前i-1件物品放入容量为v−Ci的背包中“这个子问题的最大价值F[i−1,v−Ci]加上Wi。
如果不放，问题转化为”前i-1件物品放入容量为v−Ci的背包中“,价值为F[i−1,v]。

恰好装满与非恰好装满：
如果是第一种问法，要求恰好装满背包，那么在初始化时除了dp[0]为0，其它F[1..W]均设为−∞，这样就可以保证最终得到的dp[W]是一种恰好装满背包的最优解。
如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将dp[0..W]全部设为0。
这是为什么呢？可以这样理解：初始化的F数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量
为0的背包可以在什么也不装且价值为0的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为-∞了。如果背包并非
必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了


/******************************** C++代码实现 ********************************/
#include <iostream>  
using namespace std;  
  
//物品数据结构  
typedef struct commodity  
{  
    int value;  //价值  
    int weight; //重量  
}commodity;  
  
const int N = 3;  //物品个数  
const int W = 50; //背包的容量  
  
//初始物品信息  
commodity goods[N+1]={{0,0},{60,10},{100,20},{120,30}};  
int select[N+1][W+1];  
  
int max_value();  
  
int main()  
{  
    int maxvalue = max_value();  
    cout<<"The max value is: ";  
    cout<<maxvalue<<endl;  
    int remainspace = W;  
    //输出所选择的物品列表：  
    for(int i=N; i>=1; i--)  
    {  
        if (remainspace >= goods[i].weight)  
        {  
             if ((select[i][remainspace]-select[i-1][remainspace-goods[i].weight]==goods[i].value))  
             {  
                 cout << "item " << i << " is selected!" << endl;  
                 remainspace = remainspace - goods[i].weight;//如果第i个物品被选择，那么背包剩余容量将减去第i个物品的重量 ;  
                }  
        }  
    }  
    return 0;  
}  

//获取两个数的大者  
int getMax(int a,int b)  
{  
    return a>=b?a:b;  
}  
int max_value()  
{  
    //初始没有物品时，最大值为0
    for(int k=0; k<=W; k++) select[0][k] = 0;  
    //背包为体积为空时，最大为0
    for(int k=0; k<=N; k++) select[k][0] = 0;  
  
    //逐行进行填表  
    for(int i=1; i<=N; i++) //物品编号从 1~N  
    {  
        for(int j=1; j<=W; j++) //背包容量从 1~W  
        {  
            select[i][j] = select[i-1][j];  //默认不放入背包，有可能背包放不下
            if(goods[i].weight <= j)  
            {  
                select[i][j] = getMax(select[i][j], select[i-1][j-goods[i].weight]+goods[i].value);  
            }  
        }  
    }  
    return select[N][W];  
}  

/********************** 代码结束 **************************/

优化空间复杂度：O(NV)  -->  O(V)
如果只用一个数组F[0..V ]，能不能保证第i次循环结束后F[v]中表示的就是我们定义的状态F[i, v]呢？F[i, v]是由F[i − 1, v]和F[i − 1, v − Ci]两个子问题递推而来，
能否保证在推F[i, v]时（也即在第i次主循环中推F[v]时）能够取用F[i − 1, v]和F[i − 1, v − Ci]的值呢？事实上，这要求在每次主循环中我们以v = V..0的递减顺序计算F[v]，
这样才能保证推F[v]时F[v − Ci]保存的是状态F[i − 1, v − Ci]的值。伪代码如下：

F[0..V ] = 0
for i = 1 to N
for v = V to Ci        //这里v到ci结束，本来应该 F[i, v] = F[i-1, v] 但这是一维数组，所有可以省略即F[v]就是F[i-1,v],二维数组不可以这样写
    F[v] = max{F[v], F[v − Ci] + Wi}

其中的F[v] = max{F[v], F[v − Ci] + Wi}一句，恰就对应于我们原来的转移方程，因为现在的F[v − Ci]就相当于原来的F[i − 1, v − Ci]。如果将v的循环顺序
从上面的逆序改成顺序的话，那么则成了F[i, v]由F[i, v − Ci]推导得到，与本题意不符。


完全背包问题：
F[0..V ] = 0
for i = 1 to N
for v = Ci to V  
    F[v] = max{F[v], F[v − Ci] + Wi}
